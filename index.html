<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
  <title>River Raid Clone - V2.1</title>
  <style>
    html, body { margin:0; padding:0; background:#05060a; overflow:hidden; touch-action:none; }
    canvas { display:block; margin:0 auto; background:#0a0f1f; }
    #hud {
      position:fixed; left:0; top:0; right:0;
      color:#e9eefb; font-family:system-ui, Arial; font-size:14px;
      padding:8px 10px; display:flex; flex-wrap:wrap; gap:10px; align-items:center;
      background:linear-gradient(#0a1020cc, #0a102000);
      user-select:none; pointer-events:none;
    }
    .hud-item { display:flex; align-items:center; gap:6px; }
    .bar {
      height:8px; width:120px; background:#1b2340; border-radius:999px; overflow:hidden;
      box-shadow: inset 0 0 0 1px #2a3355;
    }
    .fill { height:100%; width:50%; background:linear-gradient(90deg,#4dd,#5f8bff); }
    #overlay {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:#05060ad9; color:#fff; font-family:system-ui, Arial; text-align:center;
    }
    #overlay.hidden { display:none; }
    .card {
      background:#0e1429; border:1px solid #263055; border-radius:16px; padding:18px 20px; width:min(92vw,460px);
      box-shadow:0 10px 30px #0008;
    }
    button {
      background:#24315f; color:#fff; border:0; padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer;
      margin-top:10px;
    }
    button:hover { filter:brightness(1.08); }
    .small { opacity:.8; font-size:12px; line-height:1.3; margin-top:6px; }
    .badge {
      font-weight:800; font-size:12px; padding:2px 6px; border-radius:8px; background:#1f2b4f;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div class="hud-item"><b>Score:</b> <span id="score">0</span></div>

    <div class="hud-item">
      <b>Fuel:</b>
      <div class="bar"><div id="fuelFill" class="fill"></div></div>
      <span id="fuelTxt">100%</span>
    </div>

    <div class="hud-item"><b>Vidas:</b> <span id="lives">3</span></div>
    <div class="hud-item"><b>KM:</b> <span id="km">0.0</span></div>
    <div class="hud-item"><b>Nível:</b> <span id="level">1</span></div>

    <div class="hud-item" id="dualHud" style="display:none;">
      <span class="badge">TIRO DUPLO</span>
      <span id="dualTxt">8.0s</span>
    </div>
  </div>

  <div id="overlay">
    <div class="card">
      <h2 style="margin:0 0 4px 0;">RIVER RAID - V2.1</h2>
      <p style="margin:0 0 8px 0;">Pontes obrigatórias, inimigos que atiram e tiro duplo.</p>
      <div class="small">
        PC: WASD/Setas = mover • ESPAÇO = atirar<br/>
        Celular: arraste o dedo pra mover • toque duplo rápido pra atirar
      </div>
      <button id="startBtn">JOGAR</button>
    </div>
  </div>

  <canvas id="game"></canvas>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl   = document.getElementById("score");
  const livesEl   = document.getElementById("lives");
  const fuelFillEl= document.getElementById("fuelFill");
  const fuelTxtEl = document.getElementById("fuelTxt");
  const kmEl      = document.getElementById("km");
  const levelEl   = document.getElementById("level");
  const dualHud   = document.getElementById("dualHud");
  const dualTxtEl = document.getElementById("dualTxt");

  const overlay = document.getElementById("overlay");
  const startBtn= document.getElementById("startBtn");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  let running = false;
  let lastT = 0;

  let score = 0;
  let distancePx = 0;
  let distanceKm = 0;
  let level = 1;

  const player = {
    x: 0, y: 0, w: 26, h: 34,
    speed: 280,
    lives: 3,
    fuel: 1,
    invuln: 0,
    shootCd: 0,
    doubleShotTimer: 0
  };

  const bullets = [];
  const enemies = [];
  const enemyBullets = [];
  const fuels = [];
  const powerups = [];
  const bridges = [];
  const river = [];

  const limits = {
    maxBullets: 50,
    maxEnemies: 14,
    maxEnemyBullets: 36,
    maxFuels: 4,
    maxPowerups: 2,
    maxBridges: 2
  };

  const settings = {
    scrollSpeed: 170,
    riverMinWidth: 0.38,
    riverMaxWidth: 0.62,
    segmentH: 60,

    enemySpawnEvery: 1.05,
    fuelSpawnEvery: 3.4,
    powerSpawnEvery: 7.5,
    bridgeSpawnEvery: 9.0,

    difficultyRamp: 0.003
  };

  let enemySpawnTimer = 0;
  let fuelSpawnTimer = 0;
  let powerSpawnTimer = 0;
  let bridgeSpawnTimer = 0;

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function rand(a,b){ return a + Math.random()*(b-a); }
  function rectsOverlap(a, b){
    return a.x-a.w/2 < b.x+b.w/2 &&
           a.x+a.w/2 > b.x-b.w/2 &&
           a.y-a.h/2 < b.y+b.h/2 &&
           a.y+a.h/2 > b.y-b.h/2;
  }

  function getSegmentAtY(y){
    if (river.length === 0) return null;
    let best = river[0], bestD = Infinity;
    for (const s of river){
      const d = Math.abs(s.y - y);
      if (d < bestD){ bestD = d; best = s; }
    }
    return best;
  }

  function makeSegment(y, center, width) {
    const left  = center - width/2;
    const right = center + width/2;
    return { y, center, width, left, right };
  }

  function resetGame() {
    score = 0;
    distancePx = 0;
    distanceKm = 0;
    level = 1;

    player.lives = 3;
    player.fuel = 1;
    player.invuln = 0;
    player.shootCd = 0;
    player.doubleShotTimer = 0;

    bullets.length = 0;
    enemies.length = 0;
    enemyBullets.length = 0;
    fuels.length = 0;
    powerups.length = 0;
    bridges.length = 0;
    river.length = 0;

    player.x = canvas.width * 0.5;
    player.y = canvas.height * 0.78;

    const segCount = Math.ceil(canvas.height / settings.segmentH) + 3;
    let center = canvas.width * 0.5;
    let width  = canvas.width * 0.5;
    for (let i = 0; i < segCount; i++) {
      river.push(makeSegment(-i * settings.segmentH, center, width));
      const drift  = (Math.random() - 0.5) * canvas.width * 0.08;
      center = clamp(center + drift, canvas.width*0.25, canvas.width*0.75);
      const wdrift = (Math.random() - 0.5) * canvas.width * 0.06;
      width  = clamp(width + wdrift, canvas.width*settings.riverMinWidth, canvas.width*settings.riverMaxWidth);
    }

    updateHUD();
  }

  function updateHUD() {
    scoreEl.textContent = Math.floor(score);
    livesEl.textContent = player.lives;

    fuelFillEl.style.width = `${clamp(player.fuel,0,1)*100}%`;
    fuelTxtEl.textContent  = `${Math.floor(player.fuel*100)}%`;

    kmEl.textContent = distanceKm.toFixed(1);
    levelEl.textContent = level;

    if (player.doubleShotTimer > 0){
      dualHud.style.display = "flex";
      dualTxtEl.textContent = player.doubleShotTimer.toFixed(1) + "s";
    } else {
      dualHud.style.display = "none";
    }
  }

  const keys = {};
  window.addEventListener("keydown", e => { keys[e.code] = true; if(e.code==="Space") e.preventDefault(); });
  window.addEventListener("keyup", e => keys[e.code] = false);

  let touchActive = false;
  let lastTouch = null;

  canvas.addEventListener("pointerdown", (e) => {
    touchActive = true;
    lastTouch = { x: e.clientX, y: e.clientY };
    canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener("pointermove", (e) => {
    if (!touchActive) return;
    const dx = e.clientX - lastTouch.x;
    const dy = e.clientY - lastTouch.y;
    lastTouch = { x: e.clientX, y: e.clientY };
    player.x += dx * 1.2;
    player.y += dy * 1.2;
  });
  canvas.addEventListener("pointerup", (e) => {
    touchActive = false;
    lastTouch = null;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
  });

  let lastTapTime = 0;
  canvas.addEventListener("click", () => {
    const now = performance.now();
    if (now - lastTapTime < 280) {
      shoot();
      lastTapTime = 0;
    } else {
      lastTapTime = now;
    }
  });

  function shoot() {
    if (player.shootCd > 0) return;
    if (bullets.length > limits.maxBullets) return;

    player.shootCd = 0.16;

    const isDouble = player.doubleShotTimer > 0;
    const spread = isDouble ? 7 : 0;
    const count = isDouble ? 2 : 1;

    for (let i=0;i<count;i++){
      const offsetX = (i===0 ? -spread : spread);
      bullets.push({
        x: player.x + offsetX,
        y: player.y - player.h/2,
        vy: -560,
        r: 3,
        dmg: 1
      });
    }
  }

  function spawnEnemy() {
    if (enemies.length >= limits.maxEnemies) return;
    const topSeg = river[river.length-1];
    if (!topSeg) return;

    const x = rand(topSeg.left+30, topSeg.right-30);
    const type = Math.random() < 0.55 ? "boat" : "heli";
    enemies.push({
      x, y: -30,
      w: 28, h: 28,
      vy: settings.scrollSpeed * rand(0.6, 1.1),
      hp: type==="boat" ? 1 : 2,
      type,
      shootCd: rand(0.8, 1.8)
    });
  }

  function spawnFuel() {
    if (fuels.length >= limits.maxFuels) return;
    const topSeg = river[river.length-1];
    if (!topSeg) return;

    const x = rand(topSeg.left+36, topSeg.right-36);
    fuels.push({ x, y: -25, w: 22, h: 26, vy: settings.scrollSpeed * 0.9 });
  }

  function spawnPowerup() {
    if (powerups.length >= limits.maxPowerups) return;
    const topSeg = river[river.length-1];
    if (!topSeg) return;

    const x = rand(topSeg.left+40, topSeg.right-40);
    powerups.push({ x, y:-25, w:22, h:22, vy: settings.scrollSpeed*0.9, type:"double" });
  }

  function spawnBridge() {
    if (bridges.length >= limits.maxBridges) return;
    const topSeg = river[river.length-1];
    if (!topSeg) return;

    const width = topSeg.width;
    const center = topSeg.center;
    const left  = center - width/2;
    const right = center + width/2;

    bridges.push({
      y: -80,
      left, right,
      deckH: 18,
      hp: 10 + level*2,
      destroyed: false,
      passed: false
    });
  }

  function enemyShoot(e){
    if (enemyBullets.length >= limits.maxEnemyBullets) return;

    const speed = e.type==="heli" ? 260 : 220;
    let dx = 0, dy = 1;

    if (e.type==="heli"){
      dx = player.x - e.x;
      dy = player.y - e.y;
      const len = Math.hypot(dx,dy) || 1;
      dx /= len; dy /= len;
    }

    enemyBullets.push({
      x: e.x,
      y: e.y + e.h/2,
      w: 6, h: 10,
      vx: dx*speed,
      vy: dy*speed
    });
  }

  function hitPlayer() {
    if (player.invuln > 0) return;
    player.lives -= 1;
    player.invuln = 1.25;
    score = Math.max(0, score - 120);

    if (player.lives <= 0) {
      gameOver("Suas vidas acabaram.");
    }
    updateHUD();
  }

  function gameOver(reason) {
    running = false;
    overlay.classList.remove("hidden");
    const h2 = overlay.querySelector("h2");
    const p  = overlay.querySelector("p");
    h2.textContent = "GAME OVER";

    p.innerHTML =
      `Score final: <b>${Math.floor(score)}</b><br/>Distância: <b>${distanceKm.toFixed(1)} km</b>` +
      (reason ? `<br/>${reason}` : "");

    startBtn.textContent = "JOGAR DE NOVO";
  }

  function update(dt) {
    settings.scrollSpeed += settings.difficultyRamp * dt;

    settings.enemySpawnEvery = clamp(settings.enemySpawnEvery - 0.00012*dt, 0.55, 2);
    settings.fuelSpawnEvery  = clamp(settings.fuelSpawnEvery  - 0.00005*dt, 2.0, 5);
    settings.bridgeSpawnEvery= clamp(settings.bridgeSpawnEvery- 0.00006*dt, 6.0, 12);
    settings.powerSpawnEvery = clamp(settings.powerSpawnEvery + 0.00002*dt, 6.5, 9);

    distancePx += settings.scrollSpeed * dt;
    distanceKm = distancePx / 5000;
    const newLevel = Math.floor(distanceKm / 2) + 1;
    if (newLevel > level){
      level = newLevel;
      score += 200;
    }

    player.fuel -= dt * 0.0125;
    if (player.fuel <= 0) {
      player.fuel = 0;
      gameOver("Seu combustível acabou.");
      return;
    }

    player.invuln = Math.max(0, player.invuln - dt);
    player.shootCd = Math.max(0, player.shootCd - dt);
    player.doubleShotTimer = Math.max(0, player.doubleShotTimer - dt);

    // Movimento teclado
    let mx = 0, my = 0;
    if (keys["ArrowLeft"] || keys["KeyA"]) mx -= 1;
    if (keys["ArrowRight"]|| keys["KeyD"]) mx += 1;
    if (keys["ArrowUp"]   || keys["KeyW"]) my -= 1;
    if (keys["ArrowDown"] || keys["KeyS"]) my += 1;
    const len = Math.hypot(mx,my) || 1;
    mx/=len; my/=len;

    player.x += mx * player.speed * dt;
    player.y += my * player.speed * dt;

    if (keys["Space"]) shoot();

    player.x = clamp(player.x, 10, canvas.width-10);
    player.y = clamp(player.y, 10, canvas.height-10);

    // Rio rolando
    for (const seg of river) seg.y += settings.scrollSpeed * dt;
    while (river.length && river[0].y > canvas.height + settings.segmentH) river.shift();

    const targetSegs = Math.ceil(canvas.height / settings.segmentH) + 3;
    while (river.length < targetSegs) {
      const last = river[river.length-1] || makeSegment(0, canvas.width*0.5, canvas.width*0.5);
      const drift = (Math.random() - 0.5) * canvas.width * 0.1;
      const nCenter = clamp(last.center + drift, canvas.width*0.22, canvas.width*0.78);
      const wdrift = (Math.random() - 0.5) * canvas.width * 0.07;
      const nWidth = clamp(last.width + wdrift, canvas.width*settings.riverMinWidth, canvas.width*settings.riverMaxWidth);
      river.push(makeSegment(last.y - settings.segmentH, nCenter, nWidth));
    }

    // Colisão margem
    const seg = getSegmentAtY(player.y);
    if (seg) {
      if (player.x < seg.left + player.w/2 || player.x > seg.right - player.w/2) hitPlayer();
    }

    // Bullets player
    for (const b of bullets) b.y += b.vy * dt;
    for (let i=bullets.length-1;i>=0;i--) if (bullets[i].y < -60) bullets.splice(i,1);

    // Enemies
    enemySpawnTimer += dt;
    if (enemySpawnTimer >= settings.enemySpawnEvery) { enemySpawnTimer = 0; spawnEnemy(); }

    for (const e of enemies) {
      e.y += e.vy * dt;
      e.shootCd -= dt;
      if (e.shootCd <= 0 && e.y > 0 && e.y < canvas.height*0.7) {
        enemyShoot(e);
        e.shootCd = e.type==="boat" ? rand(1.2, 2.1) : rand(0.8, 1.6);
      }
    }
    for (let i=enemies.length-1;i>=0;i--) if (enemies[i].y > canvas.height + 80) enemies.splice(i,1);

    // bullets vs enemies
    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      for (let j=bullets.length-1;j>=0;j--){
        const b = bullets[j];
        const br = {x:b.x,y:b.y,w:b.r*2,h:b.r*2};
        if (rectsOverlap({x:e.x,y:e.y,w:e.w,h:e.h}, br)) {
          bullets.splice(j,1);
          e.hp -= b.dmg;
          if (e.hp <= 0) { enemies.splice(i,1); score += (e.type==="heli"?80:50); }
          break;
        }
      }
    }

    // enemies vs player
    for (const e of enemies) if (rectsOverlap(player, e)) { hitPlayer(); break; }

    // Enemy bullets
    for (const eb of enemyBullets){ eb.x += eb.vx * dt; eb.y += eb.vy * dt; }
    for (let i=enemyBullets.length-1;i>=0;i--){
      const eb = enemyBullets[i];
      if (eb.y > canvas.height + 60 || eb.x < -60 || eb.x > canvas.width+60) enemyBullets.splice(i,1);
    }
    for (let i=enemyBullets.length-1;i>=0;i--){
      if (rectsOverlap(player, enemyBullets[i])) { enemyBullets.splice(i,1); hitPlayer(); break; }
    }

    // Fuels
    fuelSpawnTimer += dt;
    if (fuelSpawnTimer >= settings.fuelSpawnEvery) { fuelSpawnTimer = 0; spawnFuel(); }
    for (const f of fuels) f.y += f.vy * dt;
    for (let i=fuels.length-1;i>=0;i--) if (fuels[i].y > canvas.height + 80) fuels.splice(i,1);
    for (let i=fuels.length-1;i>=0;i--){
      if (rectsOverlap(player, fuels[i])) {
        fuels.splice(i,1);
        player.fuel = clamp(player.fuel + 0.35, 0, 1);
        score += 10;
      }
    }

    // Powerups
    powerSpawnTimer += dt;
    if (powerSpawnTimer >= settings.powerSpawnEvery) { powerSpawnTimer = 0; spawnPowerup(); }
    for (const p of powerups) p.y += p.vy * dt;
    for (let i=powerups.length-1;i>=0;i--) if (powerups[i].y > canvas.height + 80) powerups.splice(i,1);
    for (let i=powerups.length-1;i>=0;i--){
      if (rectsOverlap(player, powerups[i])) {
        powerups.splice(i,1);
        player.doubleShotTimer = 8.0;
        score += 25;
      }
    }

    // Bridges
    bridgeSpawnTimer += dt;
    if (bridgeSpawnTimer >= settings.bridgeSpawnEvery) { bridgeSpawnTimer = 0; spawnBridge(); }

    for (let i=bridges.length-1;i>=0;i--){
      const br = bridges[i];
      br.y += settings.scrollSpeed * dt;

      const cx = (br.left+br.right)/2;
      const w  = br.right - br.left;
      const deckRect = { x: cx, y: br.y, w: w, h: br.deckH };

      // bullets vs ponte
      if (!br.destroyed){
        for (let j=bullets.length-1;j>=0;j--){
          const b = bullets[j];
          const brb = {x:b.x,y:b.y,w:b.r*2,h:b.r*2};
          if (rectsOverlap(deckRect, brb)) {
            bullets.splice(j,1);
            br.hp -= 1;
            if (br.hp <= 0) { br.destroyed = true; score += 200; }
            break;
          }
        }
      }

      // passou da ponte -> obrigatória destruída
      if (!br.passed && br.y > player.y + br.deckH/2) {
        br.passed = true;
        if (!br.destroyed) {
          gameOver("Você tentou passar por uma ponte que não foi destruída!");
          return;
        } else {
          score += 50;
        }
      }

      // colisão física com deck (antes de destruir)
      if (!br.destroyed && rectsOverlap(player, deckRect)) hitPlayer();

      if (br.y > canvas.height + 100) bridges.splice(i,1);
    }

    // score por sobrevivência
    score += dt * 9;
    updateHUD();
  }

  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#081025";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // rio
    ctx.fillStyle = "#0a3a6a";
    ctx.beginPath();
    for (let i=0;i<river.length;i++){
      const s = river[i];
      if (i===0) ctx.moveTo(s.left, s.y);
      else ctx.lineTo(s.left, s.y);
    }
    for (let i=river.length-1;i>=0;i--){
      const s = river[i];
      ctx.lineTo(s.right, s.y);
    }
    ctx.closePath();
    ctx.fill();

    // bordas
    ctx.strokeStyle = "#1f2b4f";
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let i=0;i<river.length;i++){
      const s = river[i];
      if (i===0) ctx.moveTo(s.left, s.y);
      else ctx.lineTo(s.left, s.y);
    }
    ctx.stroke();

    ctx.beginPath();
    for (let i=0;i<river.length;i++){
      const s = river[i];
      if (i===0) ctx.moveTo(s.right, s.y);
      else ctx.lineTo(s.right, s.y);
    }
    ctx.stroke();

    // pontes
    for (const br of bridges) drawBridge(br);

    // player
    if (!(player.invuln > 0 && Math.floor(performance.now()/80)%2===0)) drawPlayer(player.x, player.y);

    // tiros player
    ctx.fillStyle = "#cfe8ff";
    for (const b of bullets){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }

    // inimigos
    for (const e of enemies) drawEnemy(e);

    // tiros inimigos
    ctx.fillStyle="#ff6b6b";
    for (const eb of enemyBullets){
      ctx.fillRect(eb.x-eb.w/2, eb.y-eb.h/2, eb.w, eb.h);
    }

    // fuels e powerups
    for (const f of fuels) drawFuel(f);
    for (const p of powerups) drawPowerup(p);
  }

  function drawPlayer(x,y){
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle = "#eaefff";
    ctx.beginPath();
    ctx.moveTo(0, -player.h/2);
    ctx.lineTo(player.w/2, player.h/2);
    ctx.lineTo(0, player.h/3);
    ctx.lineTo(-player.w/2, player.h/2);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = "#9fb4ff"; ctx.fillRect(-player.w/2, 2, player.w, 6);
    ctx.fillStyle = "#3bd5ff"; ctx.fillRect(-4, -8, 8, 10);
    ctx.restore();
  }

  function drawEnemy(e){
    ctx.save(); ctx.translate(e.x,e.y);
    if (e.type==="boat"){
      ctx.fillStyle="#ff7b5f"; ctx.fillRect(-e.w/2, -e.h/2, e.w, e.h);
      ctx.fillStyle="#5a1b1b"; ctx.fillRect(-e.w/4, -e.h/2, e.w/2, e.h/2);
    } else {
      ctx.fillStyle="#ffd34d";
      ctx.beginPath(); ctx.arc(0,0,e.w/2,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle="#7a5b00";
      ctx.beginPath(); ctx.moveTo(-e.w/2,0); ctx.lineTo(e.w/2,0); ctx.stroke();
    }
    if (e.hp===2){
      ctx.strokeStyle="#fff"; ctx.lineWidth=2;
      ctx.strokeRect(-e.w/2-2,-e.h/2-2,e.w+4,e.h+4);
    }
    ctx.restore();
  }

  function drawFuel(f){
    ctx.save(); ctx.translate(f.x,f.y);
    ctx.fillStyle="#5bff8a"; ctx.fillRect(-f.w/2, -f.h/2, f.w, f.h);
    ctx.fillStyle="#0e3b1f"; ctx.fillRect(-f.w/4, -f.h/4, f.w/2, f.h/2);
    ctx.restore();
  }

  function drawPowerup(p){
    ctx.save(); ctx.translate(p.x,p.y);
    ctx.fillStyle="#a56bff";
    ctx.beginPath(); ctx.arc(0,0,p.w/2,0,Math.PI*2); ctx.fill();
    ctx.fillStyle="#1c0e3b"; ctx.fillRect(-4,-4,8,8);
    ctx.restore();
  }

  function drawBridge(br){
    const cx = (br.left+br.right)/2;
    const w = br.right - br.left;

    ctx.fillStyle="#6b4e2e";
    ctx.fillRect(br.left-10, br.y-18, 12, 36);
    ctx.fillRect(br.right-2, br.y-18, 12, 36);

    ctx.fillStyle = br.destroyed ? "#2b2b2b" : "#8a693e";
    ctx.fillRect(cx - w/2, br.y - br.deckH/2, w, br.deckH);

    if (!br.destroyed){
      const hpBase = (10 + level*2);
      const hpPct = clamp(br.hp / hpBase, 0, 1);
      ctx.fillStyle="#ffdd99";
      ctx.fillRect(cx - (w*0.25), br.y - br.deckH/2 - 6, w*0.5*hpPct, 3);
    }
  }

  function loop(t){
    if (!running) return;
    const dt = Math.min(0.033, (t-lastT)/1000);
    lastT = t;

    // se der erro, não trava silentemente
    try {
      update(dt);
      draw();
    } catch (err){
      console.error(err);
      gameOver("Erro interno no jogo. Recarregue a página.");
      return;
    }

    requestAnimationFrame(loop);
  }

  startBtn.addEventListener("click", () => {
    overlay.classList.add("hidden");
    overlay.querySelector("h2").textContent = "RIVER RAID - V2.1";
    overlay.querySelector("p").textContent =
      "Pontes obrigatórias, inimigos que atiram e tiro duplo.";
    startBtn.textContent = "JOGAR";

    resetGame();
    running = true;
    lastT = performance.now();
    requestAnimationFrame(loop);
  });

})();
</script>
</body>
</html>
