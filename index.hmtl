<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
  <title>River Raid Clone - Starter</title>
  <style>
    html, body { margin:0; padding:0; background:#05060a; overflow:hidden; touch-action:none; }
    canvas { display:block; margin:0 auto; background:#0a0f1f; }
    #hud {
      position:fixed; left:0; top:0; right:0;
      color:#e9eefb; font-family:system-ui, Arial; font-size:14px;
      padding:8px 10px; display:flex; gap:12px; align-items:center;
      background:linear-gradient(#0a1020cc, #0a102000);
      user-select:none; pointer-events:none;
    }
    .bar {
      height:8px; width:120px; background:#1b2340; border-radius:999px; overflow:hidden;
      box-shadow: inset 0 0 0 1px #2a3355;
    }
    .fill { height:100%; width:50%; background:linear-gradient(90deg,#4dd,#5f8bff); }
    #overlay {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:#05060ad9; color:#fff; font-family:system-ui, Arial; text-align:center;
    }
    #overlay.hidden { display:none; }
    .card {
      background:#0e1429; border:1px solid #263055; border-radius:16px; padding:18px 20px; width:min(92vw,420px);
      box-shadow:0 10px 30px #0008;
    }
    button {
      background:#24315f; color:#fff; border:0; padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer;
      margin-top:10px;
    }
    button:hover { filter:brightness(1.08); }
    .small { opacity:.8; font-size:12px; line-height:1.3; margin-top:6px; }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>Score:</b> <span id="score">0</span></div>
    <div style="display:flex;align-items:center;gap:6px;">
      <b>Fuel:</b>
      <div class="bar"><div id="fuelFill" class="fill"></div></div>
      <span id="fuelTxt">100%</span>
    </div>
    <div><b>Vidas:</b> <span id="lives">3</span></div>
  </div>

  <div id="overlay">
    <div class="card">
      <h2 style="margin:0 0 4px 0;">RIVER RAID - STARTER</h2>
      <p style="margin:0 0 8px 0;">Desvie das margens, destrua inimigos e pegue combustível.</p>
      <div class="small">
        PC: WASD/Setas = mover • ESPAÇO = atirar<br/>
        Celular: arraste o dedo pra mover • toque com 2 dedos pra atirar
      </div>
      <button id="startBtn">JOGAR</button>
    </div>
  </div>

  <canvas id="game"></canvas>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const livesEl = document.getElementById("lives");
  const fuelFillEl = document.getElementById("fuelFill");
  const fuelTxtEl = document.getElementById("fuelTxt");
  const overlay = document.getElementById("overlay");
  const startBtn = document.getElementById("startBtn");

  // --- Responsivo
  function resize() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    canvas.width = w;
    canvas.height = h;
  }
  window.addEventListener("resize", resize);
  resize();

  // --- Estado do jogo
  let running = false;
  let lastT = 0;
  let score = 0;

  const player = {
    x: 0, y: 0, w: 26, h: 34,
    speed: 280,
    lives: 3,
    fuel: 1, // 0..1
    invuln: 0
  };

  // bullets, enemies, fuels, river segments
  const bullets = [];
  const enemies = [];
  const fuels = [];
  const river = [];

  const settings = {
    scrollSpeed: 160,
    riverMinWidth: 0.38, // fração da tela
    riverMaxWidth: 0.62,
    segmentH: 60,
    enemySpawnEvery: 1.1, // s
    fuelSpawnEvery: 3.5,  // s
    difficultyRamp: 0.002 // por segundo
  };

  let enemySpawnTimer = 0;
  let fuelSpawnTimer = 0;

  function resetGame() {
    score = 0;
    player.lives = 3;
    player.fuel = 1;
    player.invuln = 0;

    bullets.length = 0;
    enemies.length = 0;
    fuels.length = 0;
    river.length = 0;

    // player no meio inferior
    player.x = canvas.width * 0.5;
    player.y = canvas.height * 0.78;

    // cria rio inicial
    const segCount = Math.ceil(canvas.height / settings.segmentH) + 2;
    let center = canvas.width * 0.5;
    let width = canvas.width * 0.5;
    for (let i = 0; i < segCount; i++) {
      river.push(makeSegment(-i * settings.segmentH, center, width));
      // variação suave
      const drift = (Math.random() - 0.5) * canvas.width * 0.08;
      center = clamp(center + drift, canvas.width*0.25, canvas.width*0.75);
      const wdrift = (Math.random() - 0.5) * canvas.width * 0.06;
      width = clamp(width + wdrift, canvas.width*settings.riverMinWidth, canvas.width*settings.riverMaxWidth);
    }

    updateHUD();
  }

  function makeSegment(y, center, width) {
    const left = center - width/2;
    const right = center + width/2;
    return { y, center, width, left, right };
  }

  function updateHUD() {
    scoreEl.textContent = Math.floor(score);
    livesEl.textContent = player.lives;
    fuelFillEl.style.width = `${Math.max(0, Math.min(1, player.fuel))*100}%`;
    fuelTxtEl.textContent = `${Math.floor(player.fuel*100)}%`;
  }

  // --- Input (teclado + touch)
  const keys = {};
  window.addEventListener("keydown", e => { keys[e.code] = true; if(e.code==="Space") e.preventDefault(); });
  window.addEventListener("keyup", e => keys[e.code] = false);

  let touchActive = false;
  let lastTouch = null;
  let touchShootCooldown = 0;

  canvas.addEventListener("pointerdown", (e) => {
    touchActive = true;
    lastTouch = { x: e.clientX, y: e.clientY };
    canvas.setPointerCapture(e.pointerId);
  });
  canvas.addEventListener("pointermove", (e) => {
    if (!touchActive) return;
    const dx = e.clientX - lastTouch.x;
    const dy = e.clientY - lastTouch.y;
    lastTouch = { x: e.clientX, y: e.clientY };

    // move player pelo arrasto (sensível)
    player.x += dx * 1.2;
    player.y += dy * 1.2;
  });
  canvas.addEventListener("pointerup", (e) => {
    touchActive = false;
    lastTouch = null;
    try { canvas.releasePointerCapture(e.pointerId); } catch {}
  });

  // Dois toques rápidos = atirar
  let lastTapTime = 0;
  canvas.addEventListener("click", (e) => {
    const now = performance.now();
    if (now - lastTapTime < 280) {
      shoot();
      lastTapTime = 0;
    } else {
      lastTapTime = now;
    }
  });

  function shoot() {
    bullets.push({
      x: player.x, y: player.y - player.h/2,
      vy: -520, r: 3
    });
  }

  // --- Util
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function rectsOverlap(a, b){
    return a.x-a.w/2 < b.x+b.w/2 &&
           a.x+a.w/2 > b.x-b.w/2 &&
           a.y-a.h/2 < b.y+b.h/2 &&
           a.y+a.h/2 > b.y-b.h/2;
  }

  // --- Spawns
  function spawnEnemy() {
    // pega segmento do topo (rio)
    const topSeg = river[river.length-1];
    const x = rand(topSeg.left+30, topSeg.right-30);
    enemies.push({
      x, y: -20,
      w: 28, h: 28,
      vy: settings.scrollSpeed * rand(0.6, 1.1),
      hp: rand(1,2) < 1.5 ? 1 : 2,
      type: Math.random() < 0.5 ? "boat" : "heli"
    });
  }

  function spawnFuel() {
    const topSeg = river[river.length-1];
    const x = rand(topSeg.left+36, topSeg.right-36);
    fuels.push({
      x, y: -20,
      w: 22, h: 26,
      vy: settings.scrollSpeed * 0.9
    });
  }

  function rand(a,b){ return a + Math.random()*(b-a); }

  // --- Atualização
  function update(dt) {
    // rampa de dificuldade
    settings.scrollSpeed += settings.difficultyRamp * dt;
    settings.enemySpawnEvery = clamp(settings.enemySpawnEvery - 0.0001*dt, 0.55, 2);
    settings.fuelSpawnEvery  = clamp(settings.fuelSpawnEvery  - 0.00005*dt, 2.0, 5);

    // combustível cai com tempo
    player.fuel -= dt * 0.012;
    if (player.fuel <= 0) {
      player.fuel = 0;
      gameOver();
      return;
    }

    // teclado move
    let mx = 0, my = 0;
    if (keys["ArrowLeft"] || keys["KeyA"]) mx -= 1;
    if (keys["ArrowRight"]|| keys["KeyD"]) mx += 1;
    if (keys["ArrowUp"]   || keys["KeyW"]) my -= 1;
    if (keys["ArrowDown"] || keys["KeyS"]) my += 1;
    const len = Math.hypot(mx,my) || 1;
    mx/=len; my/=len;
    player.x += mx * player.speed * dt;
    player.y += my * player.speed * dt;

    // tiro contínuo no espaço
    if (keys["Space"]) {
      // pequeno cooldown
      if (!player._shootCd) player._shootCd = 0;
      player._shootCd -= dt;
      if (player._shootCd <= 0) {
        shoot();
        player._shootCd = 0.18;
      }
    }

    // invulnerável pós-dano
    player.invuln = Math.max(0, player.invuln - dt);

    // --- Rio rolando
    for (const seg of river) seg.y += settings.scrollSpeed * dt;

    // remove segmentos que passaram e adiciona no topo
    while (river.length && river[0].y > canvas.height + settings.segmentH) {
      river.shift();
    }
    while (river.length < Math.ceil(canvas.height / settings.segmentH) + 3) {
      const last = river[river.length-1];
      const drift = (Math.random() - 0.5) * canvas.width * 0.1;
      const nCenter = clamp(last.center + drift, canvas.width*0.22, canvas.width*0.78);
      const wdrift = (Math.random() - 0.5) * canvas.width * 0.07;
      const nWidth = clamp(last.width + wdrift, canvas.width*settings.riverMinWidth, canvas.width*settings.riverMaxWidth);
      river.push(makeSegment(last.y - settings.segmentH, nCenter, nWidth));
    }

    // limita player dentro da tela
    player.x = clamp(player.x, 10, canvas.width-10);
    player.y = clamp(player.y, 10, canvas.height-10);

    // verifica colisão com margem do rio
    const segIdx = clamp(Math.floor(player.y / settings.segmentH), 0, river.length-1);
    const seg = river[segIdx];
    if (seg) {
      if (player.x < seg.left + player.w/2 || player.x > seg.right - player.w/2) {
        hitPlayer();
      }
    }

    // --- Bullets
    for (const b of bullets) b.y += b.vy * dt;
    for (let i=bullets.length-1;i>=0;i--){
      if (bullets[i].y < -50) bullets.splice(i,1);
    }

    // --- Enemies
    enemySpawnTimer += dt;
    if (enemySpawnTimer >= settings.enemySpawnEvery) {
      enemySpawnTimer = 0;
      spawnEnemy();
    }
    for (const e of enemies) e.y += e.vy * dt;
    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      if (e.y > canvas.height + 60) enemies.splice(i,1);
    }

    // colisão bullet x enemy
    for (let i=enemies.length-1;i>=0;i--){
      const e = enemies[i];
      for (let j=bullets.length-1;j>=0;j--){
        const b = bullets[j];
        const br = {x:b.x,y:b.y,w:b.r*2,h:b.r*2};
        if (rectsOverlap({x:e.x,y:e.y,w:e.w,h:e.h}, br)) {
          bullets.splice(j,1);
          e.hp -= 1;
          if (e.hp <= 0) {
            enemies.splice(i,1);
            score += 50;
          }
          break;
        }
      }
    }

    // colisão enemy x player
    for (const e of enemies) {
      if (rectsOverlap(player, e)) {
        hitPlayer();
        break;
      }
    }

    // --- Fuel pickups
    fuelSpawnTimer += dt;
    if (fuelSpawnTimer >= settings.fuelSpawnEvery) {
      fuelSpawnTimer = 0;
      spawnFuel();
    }
    for (const f of fuels) f.y += f.vy * dt;
    for (let i=fuels.length-1;i>=0;i--){
      const f = fuels[i];
      if (f.y > canvas.height + 60) fuels.splice(i,1);
    }
    for (let i=fuels.length-1;i>=0;i--){
      const f = fuels[i];
      if (rectsOverlap(player, f)) {
        fuels.splice(i,1);
        player.fuel = clamp(player.fuel + 0.35, 0, 1);
        score += 10;
      }
    }

    // pontuação por sobrevivência
    score += dt * 8;

    updateHUD();
  }

  function hitPlayer() {
    if (player.invuln > 0) return;
    player.lives -= 1;
    player.invuln = 1.2;
    score = Math.max(0, score - 100);
    if (player.lives <= 0) {
      gameOver();
    }
    updateHUD();
  }

  function gameOver() {
    running = false;
    overlay.classList.remove("hidden");
    overlay.querySelector("h2").textContent = "GAME OVER";
    overlay.querySelector("p").innerHTML = `Score final: <b>${Math.floor(score)}</b>`;
    startBtn.textContent = "JOGAR DE NOVO";
  }

  // --- Render
  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // fundo (terra)
    ctx.fillStyle = "#081025";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // desenha rio (polígono com margens)
    ctx.fillStyle = "#0a3a6a";
    ctx.beginPath();
    // lado esquerdo
    for (let i=0;i<river.length;i++){
      const s = river[i];
      if (i===0) ctx.moveTo(s.left, s.y);
      else ctx.lineTo(s.left, s.y);
    }
    // lado direito (volta)
    for (let i=river.length-1;i>=0;i--){
      const s = river[i];
      ctx.lineTo(s.right, s.y);
    }
    ctx.closePath();
    ctx.fill();

    // bordas do rio
    ctx.strokeStyle = "#1f2b4f";
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let i=0;i<river.length;i++){
      const s = river[i];
      if (i===0) ctx.moveTo(s.left, s.y);
      else ctx.lineTo(s.left, s.y);
    }
    ctx.stroke();

    ctx.beginPath();
    for (let i=0;i<river.length;i++){
      const s = river[i];
      if (i===0) ctx.moveTo(s.right, s.y);
      else ctx.lineTo(s.right, s.y);
    }
    ctx.stroke();

    // player (avião)
    if (player.invuln > 0 && Math.floor(performance.now()/80)%2===0) {
      // pisca
    } else {
      drawPlayer(player.x, player.y);
    }

    // bullets
    ctx.fillStyle = "#cfe8ff";
    for (const b of bullets) {
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }

    // enemies
    for (const e of enemies) drawEnemy(e);

    // fuels
    for (const f of fuels) drawFuel(f);
  }

  function drawPlayer(x,y) {
    ctx.save();
    ctx.translate(x,y);
    // corpo
    ctx.fillStyle = "#eaefff";
    ctx.beginPath();
    ctx.moveTo(0, -player.h/2);
    ctx.lineTo(player.w/2, player.h/2);
    ctx.lineTo(0, player.h/3);
    ctx.lineTo(-player.w/2, player.h/2);
    ctx.closePath();
    ctx.fill();
    // asa
    ctx.fillStyle = "#9fb4ff";
    ctx.fillRect(-player.w/2, 2, player.w, 6);
    // cockpit
    ctx.fillStyle = "#3bd5ff";
    ctx.fillRect(-4, -8, 8, 10);
    ctx.restore();
  }

  function drawEnemy(e) {
    ctx.save();
    ctx.translate(e.x, e.y);
    if (e.type==="boat") {
      ctx.fillStyle="#ff7b5f";
      ctx.fillRect(-e.w/2, -e.h/2, e.w, e.h);
      ctx.fillStyle="#5a1b1b";
      ctx.fillRect(-e.w/4, -e.h/2, e.w/2, e.h/2);
    } else {
      ctx.fillStyle="#ffd34d";
      ctx.beginPath();
      ctx.arc(0,0,e.w/2,0,Math.PI*2);
      ctx.fill();
      ctx.strokeStyle="#7a5b00";
      ctx.beginPath();
      ctx.moveTo(-e.w/2,0); ctx.lineTo(e.w/2,0);
      ctx.stroke();
    }
    // life hint
    if (e.hp===2){
      ctx.strokeStyle="#fff";
      ctx.lineWidth=2;
      ctx.strokeRect(-e.w/2-2,-e.h/2-2,e.w+4,e.h+4);
    }
    ctx.restore();
  }

  function drawFuel(f) {
    ctx.save();
    ctx.translate(f.x, f.y);
    ctx.fillStyle="#5bff8a";
    ctx.fillRect(-f.w/2, -f.h/2, f.w, f.h);
    ctx.fillStyle="#0e3b1f";
    ctx.fillRect(-f.w/4, -f.h/4, f.w/2, f.h/2);
    ctx.restore();
  }

  // --- Game loop
  function loop(t) {
    if (!running) return;
    const dt = Math.min(0.033, (t-lastT)/1000);
    lastT = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  startBtn.addEventListener("click", () => {
    overlay.classList.add("hidden");
    overlay.querySelector("h2").textContent = "RIVER RAID - STARTER";
    overlay.querySelector("p").textContent = "Desvie das margens, destrua inimigos e pegue combustível.";
    startBtn.textContent = "JOGAR";

    resetGame();
    running = true;
    lastT = performance.now();
    requestAnimationFrame(loop);
  });

})();
</script>
</body>
</html>
